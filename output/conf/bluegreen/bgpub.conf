lua_shared_dict dict_rule_data 16m;
lua_shared_dict dogs 1m;

init_by_lua '
    package.path = string.format("$s;./lua/com/qtj/bgpub/?.lua;./lua/lib/?.lua;./lua/conf/?.lua;", package.path)
    cjson = require "cjson"
    lua_code_cache = on
';

init_worker_by_lua_block {
    local bluegreen_api = require("api.bluegreen_api")
    bluegreen_api:init_worker()
} 

server {
    listen 8899;
    server_name  localhost;

    location = /favicon.ico {
            log_not_found off;
            access_log off;
    }

    location /echo {
        content_by_lua_block {
            local workCount = ngx.worker.count()
            if workCount ~= nil and workCount > 0 then
                local i = 1
                repeat 
                    ngx.say("xxxx: " .. i)
                    i = i + 1
                until workCount < i
            end
            ngx.say("yes echo" .. ngx.worker.count())
        }
    }
    
    location /ffi {
        content_by_lua_block {
            local ffi = require "ffi"

            local my_info = require("jack")
            ffi.cdef[[
                int printf(const char* fmt, ...);
            ]]

            ffi.C.printf("Hello %s", world)  
            ngx.say(package.path)          
        }
    }

    # location /bgpub/echo {
    # 	echo "bgpub";
    # }

    # location /bgpub/content_lua {
    #     content_by_lua_block {
    #         ngx.say("content: " .. package.path)
    #     }
    # }

    # location /bgpub/getservice {
    #     content_by_lua_block {
    #         local redis = require("dal.redis_dal")
    #         local result = redis.conn()
    #         ngx.say("result: " .. result)
    #         ngx.say("done")
    #     }
    # }

    # location /bgpub/redis {
    #     content_by_lua_block {
    #         local redis = require("api.redis_api")
    #         local redis_conn = redis.redisconn()
    #         ngx.say("done")
    #     }
    # }

    # 读取redis服务对应的规则数据，存入到 nginx dict 中
    #
    # curl "http://localhost:8899/bgpub/ruleset?service=ss,apollo,aka"
    location /bgpub/rule/set {
        set $service_name $arg_service;
        content_by_lua_block {
            local s_key = ngx.var.service_name  --服务名
            local conf = {["s_key"] = s_key}

            local bluegreen_api = require("api.bluegreen_api")
            local code, result = bluegreen_api:ruleset(conf)

            if not code then
                ngx.say(string.format("%d, %s", -1, cjson.encode(result)))
            else
                ngx.say(string.format("%d, %s", code, cjson.encode(result)))
            end
            
        }
    }

    # get rule data from ngx.shared.dict.  limit 100 item. 
    # can query a service by:  service=xxx
    #
    # curl "http://localhost:8899/bgpub/ruleget?service=apollo"
    location /bgpub/rule/get {
        set $service_name $arg_service;

        content_by_lua_block {
            local s_key = ngx.var.service_name  --服务名
            local conf = {["s_key"] = s_key}

            local bluegreen_api = require("api.bluegreen_api")
            local result, err = bluegreen_api:ruleget(conf)
             
            --local rule_data_cache = ngx.shared["dict_rule_data"]
            --local switch_keys = rule_data_cache:get_keys(100)  
            --local result = {} 
            --for k, v in ipairs(switch_keys) do       
            --    result[v] = rule_data_cache:get(v)
            --end
            ngx.print(cjson.encode(result) .. "\n")
        }
    }

    # delete rule data by service_name
    #
    # curl "http://localhost:8899/bgpub/ruledelete?service=apollo"
    location /bgpub/rule/delete {
        set $service_name $arg_service;
        content_by_lua_block {
            local s_key = ngx.var.service_name  --服务名
            if not s_key or string.len(s_key) < 1 then
                ngx.say("no service")
            else 
                local conf = {["s_key"] = s_key}

                local bluegreen_api = require("api.bluegreen_api")
                local code, err = bluegreen_api:ruledelete(conf)
                ngx.say("Succeed delete rule data for [" .. s_key .. "]")
            end
        }
    }

    # update switch value, make sure value in configbase.switch_enum
    #
    # curl "http://localhost:8899/bgpub/switchupdate?service=apollo&switch=TEST"
    location /bgpub/switch/update {
        set $service_name $arg_service;
        set $switch_value $arg_switch;

        content_by_lua_block {
            local s_key = ngx.var.service_name  --服务名
            local switch_value = ngx.var.switch_value  
            if not s_key or string.len(s_key) < 1 then
                ngx.say("no service")
                return
            end

            if not switch_value or string.len(switch_value) < 1 then
                ngx.say("no switch data")
                return
            end

            local conf = {["s_key"] = s_key, ["switch_value"] = switch_value}
            local bluegreen_api = require("api.bluegreen_api")
            local code, err = bluegreen_api:switchupdate(conf)
            ngx.say(string.format("Update [%s]'s switch to %s. return code: %s, msg: %s", s_key, switch_value, code, err))
        }
    }

    location /bgpub/ups/get {
        set $service_name $arg_service;
        set $group_name   $arg_group;

        content_by_lua_block {
            local s_key = ngx.var.service_name  --服务名
            local g_key = ngx.var.group_name  -- group name
            local conf = {["s_key"] = s_key, ["g_key"] = g_key}

            local bluegreen_api = require("api.bluegreen_api")
            local result = bluegreen_api:upstream_get(conf)
            ngx.say(cjson.encode(result))
        }
    }

    location /bgpub/ups/add_server {
        set $ups     $arg_upstream;
        set $ipaddr  $arg_ipaddr;

        content_by_lua_block {
            local ups_name = ngx.var.ups
            local ip_addr = ngx.var.ipaddr

            local upstream = require "ngx.upstream"
            local add_server = upstream.add_server

            -- ngx.print("ip_addr: " .. ip_addr)
            local ok,err = add_server(ups_name, ip_addr, 1, 1, 10, false)

            local ngxPid = ngx.worker.id()
            if err ~= nil then
                ngx.say(tostring(ngxPid) .. " -> Failed add " .. ip_addr .. " to upstream: " .. ups_name)
            else
                ngx.say(tostring(ngxPid) .. " -> Succeed add " .. ip_addr .. " to upstream: " .. ups_name)
            end
        }
    }

    location /bgpub/ups/remove_server {
        set $ups     $arg_upstream;
        set $ipaddr  $arg_ipaddr;

        content_by_lua_block {
            local ups_name = ngx.var.ups
            local ip_addr = ngx.var.ipaddr

            local upstream = require "ngx.upstream"
            local remove_server = upstream.remove_server

            -- ngx.print("ip_addr: " .. ip_addr)
            local ok,err = remove_server(ups_name, ip_addr)
            local ngxPid = ngx.worker.id()
            if err ~= nil then
                ngx.say(tostring(ngxPid) .. " -> Failed remove " .. ip_addr .. " from upstream: " .. ups_name)
            else
                ngx.say(tostring(ngxPid) .. " -> Succeed remove " .. ip_addr .. " from upstream: " .. ups_name)
            end
        }
    }


    location /bgpub/ups/save_to_redis {

        set $service_name $arg_service;
        set $group_name   $arg_group;

        content_by_lua_block {
            local s_key = ngx.var.service_name  --服务名
            local g_key = ngx.var.group_name  -- group name
            local conf = {["s_key"] = s_key, ["g_key"] = g_key}

            local bluegreen_api = require("api.bluegreen_api")
            local result = bluegreen_api:upstream_save_to_redis(conf)
            ngx.say(cjson.encode(result))
        }
    }
}   